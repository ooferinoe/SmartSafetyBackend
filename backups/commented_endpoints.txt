import logging, time, threading, cv2, requests, numpy as np, os, firebase_admin, cloudinary, cloudinary.uploader, tempfile, smtplib
from typing import Optional, Tuple, Dict, Any
from fastapi import APIRouter, Request, BackgroundTasks, Depends, Response, Query, UploadFile, File, HTTPException
from fastapi.responses import JSONResponse, StreamingResponse
from config import STREAM_URL, CAMERA_ID, MODEL_SERVICE_URL, CLOUDINARY_CLOUD_NAME, CLOUDINARY_API_KEY, CLOUDINARY_API_SECRET, FIREBASE_CRED_PATH, GMAIL_USER, GMAIL_PASS
from services.model_client import predict_frame_via_service
from services.processor import process_frame_from_model_response
from services.storage import add_violation, query_violations_by_timestamp
from services.emailer import send_alert
from pydantic import BaseModel
from firebase_admin import credentials, firestore
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

# # simple in-memory cache for last model response (thread-safe)
# _model_cache = {"resp": None, "ts": 0.0}
# _model_cache_lock = threading.Lock()
# _MODEL_TTL = 2.0  # seconds, adjust as needed


# def _get_frame_and_run_model() -> Tuple[Optional[Dict[str, Any]], Optional[JSONResponse]]:
#     """
#     Fetch frame and run model ONCE, but reuse cached model_resp for _MODEL_TTL seconds.
#     Returns (model_response, None) on success, or (None, error_response) on failure.
#     """
#     now = time.time()
#     with _model_cache_lock:
#         if _model_cache["resp"] is not None and (now - _model_cache["ts"]) <= _MODEL_TTL:
#             return _model_cache["resp"], None

#     # fetch frame + call model (only when cache expired)
#     try:
#         r = requests.get(STREAM_URL, timeout=5)
#         r.raise_for_status()
#         jpg = np.frombuffer(r.content, dtype=np.uint8)
#         frame = cv2.imdecode(jpg, cv2.IMREAD_COLOR)
#         if frame is None:
#             raise Exception("failed to decode frame")
#     except Exception as e:
#         logger.exception("Helper: failed to fetch frame")
#         return None, JSONResponse({"error": f"Failed to fetch frame: {e}"}, status_code=500)

#     try:
#         model_resp = predict_frame_via_service(MODEL_SERVICE_URL, frame)
#     except Exception as e:
#         logger.exception("Helper: model call failed")
#         return None, JSONResponse({"error": f"Model call failed: {e}"}, status_code=500)

#     # store in cache
#     with _model_cache_lock:
#         _model_cache["resp"] = model_resp
#         _model_cache["ts"] = time.time()

#     return model_resp, None


# # FastAPI dependency wrapper that returns cached model response or raises error
# async def get_model_response():
#     model_resp, error = _get_frame_and_run_model()
#     if error:
#         # propagate the JSONResponse as exception (FastAPI will handle it)
#         raise error
#     return model_resp

# ModelResponse = Depends(get_model_response)

# @router.get("/get_frame_detections")
# def get_frame_detections(model_resp: dict = ModelResponse):
#     """
#     Returns the raw model response.
#     The 'model_resp' is provided by the cached dependency.
#     """
#     return JSONResponse(model_resp)


# @router.post("/detect")
# async def detect_ppe_violation(file: UploadFile = File(...)):
#     image_bytes = await file.read()
#     jpg = np.frombuffer(image_bytes, dtype=np.uint8)
#     frame = cv2.imdecode(jpg, cv2.IMREAD_COLOR)
#     if frame is None:
#         return {"error": "Failed to decode image"}
#     result = predict_frame_via_service(MODEL_SERVICE_URL, frame)
#     global latest_webcam_detection
#     latest_webcam_detection = result
#     return result

# # , model_resp: dict = ModelResponse ------------v



# @router.post("/send_alert_email")
# async def post_send_alert_email(request: Request):
#     data = await request.json()
#     to = data.get("to_email") or data.get("alertSentTo") or data.get("to")
#     violation_type = data.get("violationType") or data.get("violation_type") or data.get("type")
#     confidence = data.get("confidence")
#     timestamp = data.get("timestamp") or data.get("date_time")
#     try:
#         send_alert(to, violation_type, confidence, timestamp)
#         return JSONResponse({"success": True})
#     except Exception as e:
#         logger.exception("send_alert_email failed")
#         return JSONResponse({"error": f"send_alert failed: {e}"}, status_code=500)
    
# @router.get("/detect_ppe")
# def detect_ppe(STREAM_URL: str = Query(...)):
#     """
#     Captures a frame from the IP camera (supports both HTTP image and RTSP stream), sends it to the model API, and returns detection results.
#     """
#     frame = None
#     if STREAM_URL.lower().startswith("http"):
#         try:
#             r = requests.get(STREAM_URL, timeout=5)
#             r.raise_for_status()
#             jpg = np.frombuffer(r.content, dtype=np.uint8)
#             frame = cv2.imdecode(jpg, cv2.IMREAD_COLOR)
#             if frame is None:
#                 return {"error": "Failed to decode image from HTTP URL.", "details": f"Content length: {len(r.content)}"}
#         except requests.exceptions.ConnectionError as ce:
#             return {"error": "Connection error to camera URL.", "details": str(ce)}
#         except requests.exceptions.Timeout as te:
#             return {"error": "Timeout when connecting to camera URL.", "details": str(te)}
#         except requests.exceptions.RequestException as re:
#             return {"error": "Request error when connecting to camera URL.", "details": str(re)}
#         except Exception as e:
#             return {"error": f"Failed to fetch image from HTTP URL: {e}", "details": str(e)}
#     elif STREAM_URL.lower().startswith("rtsp"):
#         cap = cv2.VideoCapture(STREAM_URL)
#         ret, frame = cap.read()
#         cap.release()
#         if not ret or frame is None:
#             return {"error": "Failed to capture frame from RTSP stream."}
#     else:
#         return {"error": "Unsupported STREAM_URL protocol. Use http or rtsp."}

#     result = predict_frame_via_service(MODEL_SERVICE_URL, frame)
#     return result


final_upload_and_update
    try:
        print("INFO (Thread): Uploading AVI to Cloudinary...")
        upload_result = cloudinary.uploader.upload(temp_video_path, resource_type="video", folder="violations")
        public_id = upload_result.get('public_id')
        footage_url = f"https://res.cloudinary.com/{CLOUDINARY_CLOUD_NAME}/video/upload/f_mp4/{public_id}.mp4"
        if footage_url:
            print(f"INFO (Thread): MP4 URL generated. Updating docs and sending email...")
            for doc_id in violation_docs:
                doc_ref = db.collection("violations").document(doc_id)
                doc_ref.update({"footageUrl": footage_url})
                snapshot = doc_ref.get()
                if snapshot.exists and not snapshot.to_dict().get("alertSent"):
                    send_email_alert_from_backend(snapshot.to_dict(), footage_url)
                    
    except Exception as e:
        print(f"FATAL ERROR in upload thread: {e}")
        
    finally:
        os.remove(temp_video_path)
        print("INFO (Thread): Upload task finished and temp file deleted.")









@router.get("/detect_ipcam")
def detect_ipcam(background_tasks: BackgroundTasks):
    global latest_webcam_detection, last_api_call_time, is_on_cooldown, detection_lock
    last_api_call_time = time.time()

    # Try to acquire the lock non-blocking
    acquired = detection_lock.acquire(blocking=False)
    if not acquired or is_on_cooldown:
        if acquired:
            try:
                detection_lock.release()
            except RuntimeError:
                pass
        return JSONResponse({
            "violations_stored": 0,
            "unresolved": [],
            "detections": [],
            "width": 1920,
            "height": 1080,
            "message": "System is on cooldown or busy."
        }, status_code=429)

    try:
        if latest_webcam_detection is None:
            try:
                detection_lock.release()
            except RuntimeError:
                pass
            return JSONResponse({
                "violations_stored": 0,
                "unresolved": [],
                "detections": [],
                "width": 1920,
                "height": 1080
            })

        result = process_frame_from_model_response(latest_webcam_detection, background_tasks=background_tasks)
        violations = result.get("violations", [])
        for v in violations:
            logger.info(
                "Unresolved violation: type=%s confidence=%s id=%s camera=%s",
                v.get("violationType") or v.get("type"),
                v.get("confidence"),
                v.get("violationId"),
                v.get("footageId") or v.get("camera_id", CAMERA_ID),
            )
        violation_ids = [v.get("violationId") for v in violations if v.get("violationId")]
        
        is_on_cooldown = True
        
        def upload_and_release(temp_video_path, violation_ids):
            global is_on_cooldown
            
            try:
                final_upload_and_update(temp_video_path, violation_ids)
                
            finally:
                # Enforce cooldown period and then release the detection lock
                try:
                    print(f"INFO: Starting {COOLDOWN_SECONDS}-second cooldown.")
                    time.sleep(COOLDOWN_SECONDS)
                except Exception as e:
                    print(f"WARN: cooldown sleep interrupted: {e}")

                is_on_cooldown = False
                try:
                    if detection_lock.locked():
                        detection_lock.release()
                except RuntimeError:
                    pass
                print("INFO: Cooldown finished. System is ready.")
            
        background_tasks.add_task(upload_and_release, None, violation_ids) 
        return JSONResponse({
            "violations_stored": result.get("violations_stored", 0),
            "unresolved": [v.get("violationType") or v.get("type") for v in violations],
            "detections": latest_webcam_detection.get("detections", []),
            "width": latest_webcam_detection.get("width", 1920),
            "height": latest_webcam_detection.get("height", 1080)
       })
        
    except Exception as e:
        logger.exception("detect_ipcam: processing failed")
        is_on_cooldown = False
        try:
            if detection_lock.locked():
                detection_lock.release()
        except RuntimeError:
            pass
        return JSONResponse({
            "violations_stored": 0,
            "unresolved": [],
            "detections": [],
            "error": str(e)
        })
        
def generate_frames():
    global output_frame, lock
    
    while True:
        with lock:
            if output_frame is None:
                time.sleep(0.1)
                continue
            (flag, encodedImage) = cv2.imencode(".jpg", output_frame)
            
        if not flag:
            continue

        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + bytearray(encodedImage) + b'\r\n')
        time.sleep(0.10)